---
title: "脆弱性から学ぶRuby処理系(CVE-2022-28739)"
emoji: "⛳"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ruby", "c"]
published: false
---

# 脆弱性から学ぶRuby処理系(CVE-2022-28739)
最近仕事でRubyを使うようになったのだが、これまで業務で使ったことのない言語だったので日々言語仕様などを勉強している。
加えて別の理由でセキュリティ周りも勉強しておきたく、良い機会なので「脆弱性の側面からRubyの処理系について学ぶ」という暴挙に出たいと思う。

# Rubyについて

# 脆弱性

# CVE-2022-28739
今回、調査対象にする脆弱性。
[公式のニュース](https://www.ruby-lang.org/ja/news/2022/04/12/buffer-overrun-in-string-to-float-cve-2022-28739/)にこんな感じで記載がある。
> String を Float に変換する内部関数のバグにより、`Kernel#Float`や`String#to_f`などの一部の変換メソッドでバッファのオーバーリードが発生する可能性があります。 典型的な結果はセグメンテーションフォールトによるプロセス終了ですが、限られた状況下では、不正なメモリ読み出しに悪用される可能性があります。

ざっくり言うと、**String → Float に変換するときバッファオーバーラン**が発生しうる脆弱性。(そのまま)
[NISTの記載](https://nvd.nist.gov/vuln/detail/CVE-2022-28739)から見るに、`CVSS`のスコアは`7.5`と比較的高め？(`10`がMaxのようなのでまあまあクリティカルぽい)
普通にセグフォで終わるケースが多いとのことだが、一部メモリ読み出しができてしまうケースがあるらしい。(めちゃくちゃ気になる)

もちろん既に[パッチ](https://github.com/ruby/ruby/commit/69f9992ed41920389d4185141a14f02f89a4d306)は当てられていて、`2.6.10`/`2.7.6`/`3.0.4`/`3.1.2`以降のバージョンを使っていれば安心。
逆に、これら以前のバージョン(`2.7.5`とか`3.1.1`とか)を使っている場合は注意が必要ということになる。

## パッチを覗いてみる
実際に当てられているパッチの内容を見てみる。
大きく分けると、本体のコードには2つの修正が加えられている。

一つ目の変更。ポインタの指す先が無効な値の場合、後処理にジャンプする分岐を追加。
```c
            if (!*++s || !(s1 = strchr(hexdigit, *s))) goto ret0;
            if (*s == '0') {
                while (*++s == '0');
+               if (!*s) goto ret;
                s1 = strchr(hexdigit, *s);
            }
            if (s1 != NULL) {
```

２つ目の変更。ポインタが有効である場合、繰り返しを続ける条件を追加。
```c
                for (; *s && (s1 = strchr(hexdigit, *s)); ++s) {
                    adj += aadj * ((s1 - hexdigit) & 15);
                    if ((aadj /= 16) == 0.0) {
-                       while (strchr(hexdigit, *++s));
+                       while (*++s && strchr(hexdigit, *s));
                        break;
                    }
                }
```

脆弱性にはまだそこまで詳しくないが、入力値によっては**何かが起きそうな匂い**はプンプン漂っている気がする。

## 試してみる
とりあえずやってみたほうが早いので試してみる。

### 事前準備
まずは試してみるための環境を用意していく。
```shell
# CRubyをクローンしてくる
$ git clone https://github.com/ruby/ruby.git

# パッチが適用されていない3.1.1に切り替える
$ git checkout tags/v3_1_1

### 👇ここからビルドしていく(依存関係は用意されている前提) ###

# configureを生成
$ ./autogen.sh

# ビルド用 & インストール用のディレクトリを作成
$ mkdir build && mkdir rubies

# ビルド用のディレクトリに移動、インストール先を指定してconfigureを実行
$ cd build
$ ../configure --prefix=path/to/ruby/rubies/v3_1_1

# 作成されたMakefileを使ってビルド
$ make install

# インストール用のディレクトリに色々作られてる (例えばbin)
$ cd ../rubies/v3_1_1/bin/
$ ls
bundle  bundler  erb  gem  irb  racc  rake  rbs  rdbg  rdoc  ri  ruby  typeprof

# CRuby 3.1.1 のできあがり
$ ./ruby --version
ruby 3.1.1p18 (2022-02-18 revision 53f5fc4236) [x86_64-linux]
```
(全然関係ないが`miniruby`っていうのも吐き出されてて「そんなのもあるのか・・・」と思った)

### 実行してみる
パッチに含まれている[テストコード](https://github.com/ruby/ruby/blob/8d142ecff9af7d60728b8cfa9138e8623985c428/test/ruby/test_float.rb#L175)を見ながら試しに実行してみる。

適当に`/tmp`とかに以下のスクリプトを作って、
```ruby
def valid_value
  2000.times do
    f = Float('0x000000000')
  end
end

def invalid_value
  2000.times do
    f = Float('0x' + ('0' * 30))
  end
end

valid_value
invalid_value
```

ビルドした`3.1.1`で実行。
```shell
$ ./ruby --version
ruby 3.1.1p18 (2022-02-18 revision 53f5fc4236) [x86_64-linux]

$ ./ruby /tmp/test.rb
<internal:kernel>:173:in `Float': invalid value for Float(): "0x000000000000000000000000000000" (ArgumentError)
	from /tmp/test.rb:9:in `block in invalid_value'
	from /tmp/test.rb:8:in `times'
	from /tmp/test.rb:8:in `invalid_value'
	from /tmp/test.rb:17:in `<main>'
```
たしかになんか起きた。
試しに`3.1.2`で実行してみても問題なく動くのがわかる。
```shell
$ ruby --version
ruby 3.1.2p20 (2022-04-12 revision 4491bb740a) [x86_64-linux]

$ ruby /tmp/test.rb
```

2000回ループしてるところなんだが、試しに単発で試してみると何事も起きずに正常終了することもあるみたいで、2000回くらいループすれば確実に異常ケース踏むみたい。

## 何が起きているのか？
たしかに、実際に不思議な挙動が起きていることがわかったので、パッチがあたっている処理ををもう少し深く見ていく。

該当のパッチがあたっているのは`strtod`という関数。
```c
double
strtod(const char *s00, char **se)
{
    ...
    for (s = s00;;s++)
        switch (*s) {
          case '-':
            sign = 1;
            /* no break */
          case '+':
            if (*++s)
                goto break2;
            /* no break */
          case 0:
            goto ret0;
          case '\t':
          ... (この辺はスキップする対象を列挙しているので省略)
          case ' ':
            continue;
          default:
            goto break2;
        }
break2:
    if (*s == '0') {
        if (s[1] == 'x' || s[1] == 'X') {
            s0 = ++s;
            adj = 0;
            aadj = 1.0;
            nd0 = -4;

            if (!*++s || !(s1 = strchr(hexdigit, *s))) goto ret0;
            if (*s == '0') {
                while (*++s == '0');
                if (!*s) goto ret;  // ここがパッチのところ①
                s1 = strchr(hexdigit, *s);
            }
    ...
```
見たところ、前半部で「符号の有り無しを判定」したり「タブ文字やらをスキップ」したりしている。
その後`0x`や`0X`で始まる文字列の場合、対象のパッチがあたっている箇所に突入していっているのがわかる。
`0x`もしくは`0X`の直後から`0 (0x30)`が続く間はスキップしており、それ以外であれば16進数の数値を`strchr`で探している。

もう一箇所は小数点を含む場合。
```c
    ...
        if (*s == '0') {
            while (*++s == '0');
            if (!*s) goto ret;  // ここがパッチのところ①
            s1 = strchr(hexdigit, *s);
        }
        if (s1 != NULL) {
            do {
                adj += aadj * ((s1 - hexdigit) & 15);
                nd0 += 4;
                aadj /= 16;
            } while (*++s && (s1 = strchr(hexdigit, *s)));
        }

        if (*s == '.') {
            dsign = 1;
            if (!*++s || !(s1 = strchr(hexdigit, *s))) goto ret0;
            if (nd0 < 0) {
                while (*s == '0') {
                    s++;
                    nd0 -= 4;
                }
            }
            for (; *s && (s1 = strchr(hexdigit, *s)); ++s) {
                adj += aadj * ((s1 - hexdigit) & 15);
                if ((aadj /= 16) == 0.0) {
                    while (*++s && strchr(hexdigit, *s));  // ここがパッチのところ②
                    break;
                }
    ...
```

なんか色々やっているみたいだが、どんな状況でこの関数が呼ばれているのかなどわからないとよくわからないので動かしながらデバッグしてみる。(ついでにRubyの処理系についても勉強にならないと企画倒れになってしまうので)

### デバッグしてみる
デバッグ用にビルドして、さっきのスクリプトを実行してみる。
```shell
# ビルド用のディレクトリに移動
$ cd path/to/ruby/build

# デバッグ用にconfigure
$ ../configure optflags="-O0" --prefix="path/to/ruby/rubies/v3_1_1"

# ビルド
$ make install
```

gdbでやっていく。
```shell
$ gdb -q --args ./ruby /tmp/test.rb
Reading symbols from ./ruby...

# とりあえず`missing/dtoa.c`の`1553`行目にブレークポイントをおいてみる
(gdb) break missing/dtoa.c:1553
Breakpoint 1 at 0x2024ba: file ../missing/dtoa.c, line 1553.

# ブレークポイントまで進める (ruby_strtodで止まっているのがわかる)
(gdb) run
Starting program: /home/kate/src/ruby/rubies/v3_1_1/bin/ruby /tmp/test.rb
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, ruby_strtod (s00=0x7ffff3717038 "0x000000", se=0x7fffffffd3c8) at ../missing/dtoa.c:1553
1553		    if (!*++s || !(s1 = strchr(hexdigit, *s))) goto ret0;

# backtraceでここまでの道のりを出力してみる
(gdb) backtrace
#0  ruby_strtod (s00=0x7ffff3717038 "0x000000", se=0x7fffffffd3c8) at ../missing/dtoa.c:1553
#1  0x0000555555648875 in rb_cstr_to_dbl_raise (p=p@entry=0x7ffff3717038 "0x000000", badcheck=badcheck@entry=1, raise=raise@entry=1, error=error@entry=0x0) at ../object.c:3276
#2  0x0000555555648e8d in rb_cstr_to_dbl_raise (error=0x0, raise=1, badcheck=1, p=0x7ffff3717038 "0x000000") at ../object.c:3268
#3  rb_str_to_dbl_raise (str=<optimized out>, badcheck=badcheck@entry=1, raise=raise@entry=1, error=error@entry=0x0) at ../object.c:3404
#4  0x000055555564e070 in rb_str_to_dbl (str=<optimized out>, badcheck=badcheck@entry=1) at ../object.c:3415
#5  0x000055555564e6ed in rb_convert_to_float (raise_exception=1, val=<optimized out>) at ../object.c:3510
#6  rb_f_float1 (ec=<optimized out>, obj=<optimized out>, arg=<optimized out>) at ../object.c:3537
#7  0x000055555578c2b9 in invoke_bf (argv=<optimized out>, bf=<optimized out>, reg_cfp=<optimized out>, ec=<optimized out>) at ../vm_insnhelper.c:5909
#8  vm_invoke_builtin_delegate (start_index=<optimized out>, bf=<optimized out>, cfp=<optimized out>, ec=<optimized out>) at ../vm_insnhelper.c:5936
#9  vm_exec_core (ec=0x7ffff3717038, initial=140737488344008) at ../insns.def:1498
#10 0x000055555577c31f in rb_vm_exec (ec=0x5555559b59b0, mjit_enable_p=true) at ../vm.c:2211
#11 0x00005555557800e8 in invoke_block (captured=<optimized out>, captured=<optimized out>, opt_pc=<optimized out>, type=<optimized out>, cref=0x0, self=140737333150440, iseq=0x7ffff37100e8, ec=0x5555559b59b0)
    at ../vm.c:1316
#12 invoke_iseq_block_from_c (me=0x0, is_lambda=<optimized out>, cref=0x0, passed_block_handler=0, kw_splat=0, argv=0x7fffffffd748, argc=1, self=140737333150440, captured=<optimized out>, ec=0x5555559b59b0)
    at ../vm.c:1372
#13 invoke_block_from_c_bh (force_blockarg=<optimized out>, is_lambda=<optimized out>, cref=<optimized out>, passed_block_handler=<optimized out>, kw_splat=<optimized out>, argv=<optimized out>, 
    argc=<optimized out>, block_handler=<optimized out>, ec=<optimized out>) at ../vm.c:1390
#14 vm_yield_with_cref (is_lambda=0, cref=0x0, kw_splat=0, argv=0x7fffffffd748, argc=1, ec=0x5555559b59b0) at ../vm.c:1427
#15 vm_yield (kw_splat=0, argv=0x7fffffffd748, argc=1, ec=0x5555559b59b0) at ../vm.c:1435
#16 rb_yield_0 (argv=0x7fffffffd748, argc=1) at ../vm_eval.c:1347
#17 rb_yield_1 (val=<optimized out>, val@entry=1) at ../vm_eval.c:1353
#18 0x000055555563ff1c in int_dotimes (num=4001) at ../numeric.c:5701
#19 0x000055555576fc97 in vm_call_cfunc_with_frame (ec=0x5555559b59b0, reg_cfp=0x7ffff6d53f50, calling=<optimized out>) at ../vm_insnhelper.c:3037
#20 0x0000555555773ff5 in vm_sendish (ec=0x5555559b59b0, reg_cfp=0x7ffff6d53f50, cd=0x555555aff970, block_handler=<optimized out>, method_explorer=mexp_search_method) at ../vm_callinfo.h:349
#21 0x000055555578ac42 in vm_exec_core (ec=0x7ffff3717038, initial=140737488344008) at ../insns.def:759
#22 0x000055555577c31f in rb_vm_exec (ec=0x5555559b59b0, mjit_enable_p=true) at ../vm.c:2211
#23 0x0000555555583c11 in rb_ec_exec_node (ec=ec@entry=0x5555559b59b0, n=n@entry=0x7ffff3710408) at ../eval.c:280
#24 0x0000555555588d7d in ruby_run_node (n=0x7ffff3710408) at ../eval.c:321
#25 0x000055555558399f in main (argc=<optimized out>, argv=<optimized out>) at ../main.c:47
```

`backtrace`の出力の一番下から辿ってみると、こんな感じで辿ってきているらしい。
- main
- ruby_run_code
- rb_ec_exec_node
- rb_vm_exec
- ... (たぶん`2000.times`とか呼んでる箇所で本筋とは関係ないので省略)
- vm_exec_core
- vm_invoke_builtin_delegate
- invoke_bf
- rb_f_float1
- rb_convert_to_float
- rb_str_to_dbl
- rb_str_to_dbl_raise
- rb_cstr_to_dbl_raise
- ruby_strtod

# 最後に
