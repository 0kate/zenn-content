---
title: "脆弱性から学ぶRailsの仕組み(CVE-2022-23633編)"
emoji: "🐈"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ruby", "rails"]
published: false
---

# 脆弱性から学ぶRailsの仕組み(CVE-2022-23633編)
少し前にやった[脆弱性からRubyを学ぶやつ](https://zenn.dev/0kate/articles/9872322bb93a58)を`Rails`でもやっていく記事。
`Rails`も仕事で使うようになったので、これも脆弱性から仕組みをちゃんと学んでみようと思う。

# 対象の読者
この記事の対象となる人はこんな感じで想定。
- `Rails`を使い始めたばかりで仕組みから学びたい人
- `Rails`はよく使ってるけど仕組みはよくわからないから知りたいという人

自分のような`Rails`初心者の方にも勉強になる記事にしたいため、「`Action Pack`って？」みたいな話を軽くする箇所もあるためその辺はご了承ください。

# Ruby on Rails
さっきから「Rails、れいるず」と言っているもの。
言わずとしれたRubyのWebアプリケーションフレームワークの1つ。
「`Rails`？あー、ピザのことね。」という方は[Wikipedia](https://ja.wikipedia.org/wiki/Ruby_on_Rails)を参照。

# 脆弱性
これはRubyの記事で記載したので割愛。
気になる方は以下の脆弱性からRubyの仕組みを学んだ記事を参照。
https://zenn.dev/0kate/articles/9872322bb93a58

# CVE-2022-23633
今回の調査対象となる脆弱性。
この脆弱性を選んだのは、比較的新しめの脆弱性なので身近に見かける可能性もあるのではと思ったのと、内容的に`Action Pack`あたりを掘り下げることになりそうなので、`Rails`の根本的な部分を学べそうな気がしたから。

[OpenCVEの脆弱性の概要](https://www.opencve.io/cve/CVE-2022-23633)としてはこんな感じ。
> Action Pack is a framework for handling and responding to web requests. Under certain circumstances response bodies will not be closed. In the event a response is *not* notified of a `close`, `ActionDispatch::Executor` will not know to reset thread local state for the next request. This can lead to data being leaked to subsequent requests.This has been fixed in Rails 7.0.2.1, 6.1.4.5, 6.0.4.5, and 5.2.6.1. Upgrading is highly recommended, but to work around this problem a middleware described in GHSA-wh98-p28r-vrc9 can be used.

雑に翻訳すると、「特定の条件下で、`ActionDispatch::Executor`によってリクエストを処理するスレッドの終了処理がうまく行われず、直後のリクエストにスレッドの内部状態が引き継がれてしまう」らしい。

[GitHubに書いてある脆弱性の概要](https://github.com/rails/rails/security/advisories/GHSA-wh98-p28r-vrc9)には若干違う記載があって、こっちのほうがもっと具体的に書いてある。
> Under certain circumstances response bodies will not be closed, for example a bug in a webserver or a bug in a Rack middleware. In the event a response is not notified of a close, ActionDispatch::Executor will not know to reset thread local state for the next request. This can lead to data being leaked to subsequent requests, especially when interacting with ActiveSupport::CurrentAttributes.

基本的な内容は同じだが、こっちに更に追加で書いてあるのが「`ActiveSupport::CurrentAttributes`を使っているときは特にそうなる」らしい。

もちろん既に公開されている情報のためパッチは当たっていて、`5.2.6.1`/`6.0.4.5`/`6.1.4.5`/`7.0.2.1`以降の`Rails`を使っていれば大丈夫。

# パッチを見てみる
CVEの概要と`Action Pack`についてわかった所で、実際に当てられているパッチを見てみる。
OpenCVEとかに貼られているリンクから飛べるGitHub上のパッチはこれ。
```diff ruby
$ git diff 761a2e25520566d932c41c740b8a5c513d839de8 f9a2ad03943d5c2ba54e1d45f155442b519c75da
diff --git a/activesupport/lib/active_support/reloader.rb b/activesupport/lib/active_support/reloader.rb
index 2f81cd4f80..e751866a27 100644
--- a/activesupport/lib/active_support/reloader.rb
+++ b/activesupport/lib/active_support/reloader.rb
@@ -58,7 +58,7 @@ def self.reload!
       prepare!
     end

-    def self.run! # :nodoc:
+    def self.run!(reset: false) # :nodoc:
       if check!
         super
       else
```
このパッチは`ActiveSupport::Reloader#run!`に当てられている。
「え、これだけ？」と思うかもしれないが、実はこのコミットは副次的なもので、もう少しだけ前のコミットログを辿るとそっちに[本質的な修正](https://github.com/rails/rails/commit/3c0420c431954d05fef2015a27281069e68cce0c)が加えられている。
全部ここに載せるには少しだけ長いので、重要そうな部分だけ抜き出す。

```diff ruby
diff --git a/actionpack/lib/action_dispatch/middleware/executor.rb b/actionpack/lib/action_dispatch/middleware/executor.rb
index 85326e313b..1878d64715 100644
--- a/actionpack/lib/action_dispatch/middleware/executor.rb
+++ b/actionpack/lib/action_dispatch/middleware/executor.rb
@@ -9,7 +9,7 @@ def initialize(app, executor)
     end

     def call(env)
-      state = @executor.run!
+      state = @executor.run!(reset: true)
       begin
         response = @app.call(env)
         returned = response << ::Rack::BodyProxy.new(response.pop) { state.complete! }
```
⬆ まずは概要分にも書かれていた`ActionDispatch::Executor#call`の変更。
`reset`引数に`true`を渡しいる。先程の`ActiveSupport::Reloader#run!`に加えられている`reset`引数と関係ありそう。

```diff ruby
diff --git a/activesupport/lib/active_support/execution_wrapper.rb b/activesupport/lib/active_support/execution_wrapper.rb
index 87d90839ca..5a4a9b2c60 100644
--- a/activesupport/lib/active_support/execution_wrapper.rb
+++ b/activesupport/lib/active_support/execution_wrapper.rb
@@ -64,18 +64,21 @@ def self.register_hook(hook, outer: false)
     # after the work has been performed.
     #
     # Where possible, prefer +wrap+.
-    def self.run!
-      if active?
-        Null
+    def self.run!(reset: false)
+      if reset
+        lost_instance = IsolatedExecutionState.delete(active_key)
+        lost_instance&.complete!
       else
-        new.tap do |instance|
-          success = nil
-          begin
-            instance.run!
-            success = true
-          ensure
-            instance.complete! unless success
-          end
+        return Null if active?
+      end
+
+      new.tap do |instance|
+        success = nil
+        begin
+          instance.run!
+          success = true
+        ensure
+          instance.complete! unless success
         end
       end
     end
@@ -105,27 +108,20 @@ def self.perform # :nodoc:
       end
     end

-    class << self # :nodoc:
-      attr_accessor :active
-    end
-
     def self.error_reporter
       @error_reporter ||= ActiveSupport::ErrorReporter.new
     end

-    def self.inherited(other) # :nodoc:
-      super
-      other.active = Concurrent::Hash.new
+    def self.active_key # :nodoc:
+      @active_key ||= :"active_execution_wrapper_#{object_id}"
     end

-    self.active = Concurrent::Hash.new
-
     def self.active? # :nodoc:
-      @active[IsolatedExecutionState.unique_id]
+      IsolatedExecutionState.key?(active_key)
     end

     def run! # :nodoc:
-      self.class.active[IsolatedExecutionState.unique_id] = true
+      IsolatedExecutionState[self.class.active_key] = self
       run
     end

@@ -140,7 +136,7 @@ def run # :nodoc:
     def complete!
       complete
     ensure
-      self.class.active.delete(IsolatedExecutionState.unique_id)
+      IsolatedExecutionState.delete(self.class.active_key)
     end

     def complete # :nodoc:
```
⬆ 次は`ActiveSupport::ExecutionWrapper`に加えられている変更。
`ActiveSupport::IsolatedExecutionState`なるものが出てくる。
「`IsolatedExecutionState`とかいうクラスを、自分のクラス変数に保存」から「`IsolatedExecutionState`のクラス変数に自分自身のインスタンスを保存」に変わっている？ように見える。

## Workaround
さらに、どうしてもパッチ適用版にアップグレードできない場合の代替策も一応用意されており、次のRackミドルウェアを適用することで一先ずなんとかなるらしい。
```ruby
class GuardedExecutor < ActionDispatch::Executor
  def call(env)
    ensure_completed!
    super
  end

  private

    def ensure_completed!
      @executor.new.complete! if @executor.active?
    end
end

# Ensure the guard is inserted before ActionDispatch::Executor
Rails.application.configure do
  config.middleware.swap ActionDispatch::Executor, GuardedExecutor, executor
end
```
`GuardedExecutor#call`の中で、`ActionDispatch::Executor#call`の直前に`complete!`を必ず呼び出すようにしている。

## Pumaとの関係
実はこの脆弱性、Ruby製のWebサーバー`Puma`とも密接に関係しており、[GitHub上のPRの会話](https://github.com/puma/puma/pull/2812)とかを見てみると面白いバグが起きていることがわかる。
今回は`Rails`の仕組みに集中したいので`Puma`に関してはそこまで深く踏み込まない。

# 事前知識
脆弱性の概要やパッチのが確認できた所で実際にもう少し深く調べていきたいが、ここまでで`ActionDispatch::Executor`やら`ActiveSupport::ExecutionWrapper`やら`ActiveSupport::IsolatedExecutionState`やら`ActiveSupport::CurrentAttributes`やら色々出てきて`Rails`入門したて人間には辛いものがあるので、少しだけこの辺の事前知識について調べて準備しておく。

### `Action Pack`
まずは基本が大事ということで`Action Pack`から。`Action Dispatch`やらもここに関係している。
📢 公式の記載を噛み砕いた内容なので、こんなもの常識だという方はガンガンスキップ推奨。

#### [`Action Pack`](https://github.com/rails/rails/blob/main/actionpack/README.rdoc#action-pack--from-request-to-response-) is 何?
`Ruby on Rails`は`MVC`パターンに準拠したフレームワークなわけだが、`Action Pack`はその[コントローラレイヤー](https://github.com/rails/rails#controller-layer)に相当するもので、HTTPリクエスト・レスポンスのハンドリングに関する責務を担っている部分。
`Action Dispatch`/`Action Controller`という2つのモジュールから構成されている。

##### `Action Dispatch`
> Action Dispatch, which parses information about the web request, handles routing as defined by the user, and does advanced processing related to HTTP such as MIME-type negotiation, decoding parameters in POST, PATCH, or PUT bodies, handling HTTP caching logic, cookies and sessions.

雑に翻訳すると、「HTTPリクエストを解釈(キャッシュやクッキー・セッションの処理なども含む)し、ユーザーが定義したコントローラに適切に受け渡す」。

##### `Action Controller`
> Action Controller, which provides a base controller class that can be subclassed to implement filters and actions to handle requests. The result of an action is typically content generated from views.

こちらも雑に翻訳すると、「`Action Dispatcher`から受け渡されたリクエストを実際に処理する部分(処理結果はビューによって処理されたものが一般的)」。
実際に`Rails`を使ってアプリケーションを実装していく際に、`app/controllers`にガンガン書いていくやつ。

### `Active Support`
一応`Active Support`も。
(Active Supportの説明を入れる)

### `ActionDispatch::Executor`
`ActionDispatch::Executor`の実態は[`rails/actionpack/lib/action_dispatch/middleware/executor.rb:7`](https://github.com/rails/rails/blob/8015c2c2cf5c8718449677570f372ceb01318a32/actionpack/lib/action_dispatch/middleware/executor.rb#L7)にある。
「コード読んで挙動調べるか...」と思ったが[`Rails Guide`](https://guides.rubyonrails.org/threading_and_code_execution.html#executor)に既に説明が書いてある。

それっぽく要約すると、「`Rails`のフレームワークを構成するコード」と「アプリケーションのコード」を分離するためのものらしい。
`to_run`と`to_complete`という2種類のコールバックを受け取り、`to_run` → アプリケーションのコード → `to_complete`という順番で実行する。
`Rails`内部で使われているデフォルトの使い方は以下。
- 自動ロードやリロードのスレッドが安全な位置で稼働しているかを追跡する
- Active Recordのクエリキャッシュを有効/無効する
- Active Recordのコネクションをコネクションプールにリリースする
- 内部キャッシュの制限

### `ActiveSupport::ExecutionWrapper`
[`rails/activesuport/lib/active_support/execution_wrapper.rb`](https://github.com/rails/rails/blob/3c0420c431954d05fef2015a27281069e68cce0c/activesupport/lib/active_support/execution_wrapper.rb)にある。
前述の`Executor`
この **事前処理** に後述の`IsolatedExecutionState`が関わってくる。

### `ActiveSupport::Reloader`

### `ActiveSupport::IsolatedExecutionState`
[`rails/activesupport/lib/active_support/isolated_execution.rb`](https://github.com/rails/rails/blob/3c0420c431954d05fef2015a27281069e68cce0c/activesupport/lib/active_support/isolated_execution_state.rb)にある。
これも名前通り、「スレッドごとに隔離された実行状態」を管理するオブジェクト。
現在の実行単位(`Thread`もしくは`Fiber`)の`active_support_execution_state`を間接的に参照するためのオブジェクト。

### `ActiveSupport::CurrentAttributes`
[`rails/activesupport/lib/active_support/current_attribute.rb`](https://github.com/rails/rails/blob/main/activesupport/lib/active_support/current_attributes.rb)にある。
> Abstract super class that provides a thread-isolated attributes singleton, which resets automatically before and after each request. This allows you to keep all the per-request attributes easily available to the whole system.

リクエストを処理するスレッドごとに、状態を保存しておく用のシングルトンオブジェクトとして機能するクラス。
使い方は、ソースコードのコメントとしてわかりやすいサンプルが書かれているのでそちらを参照。
ちなみにこの[`ActiveSupport::CurrentAttributes#current_instances`](https://github.com/rails/rails/blob/main/activesupport/lib/active_support/current_attributes.rb#L163)でも前述の`IsolatedExecutionState`を使っている。
```ruby
def current_instances
  IsolatedExecutionState[:current_attributes_instances] ||= {}
end
```

# 試してみる
今回もパッチ適用後のテストコードがあるので、それを見ながら変な挙動を起こしそうなコードを書いてみる。
`Rails`本体から切り離しても動くように分解して雑に書き換え。
```ruby
require 'action_dispatch/middleware/executor'
require 'active_support/executor'
require 'active_support/isolated_execution_state'

$executor = Class.new(ActiveSupport::Executor)

def middleware(inner_app)
  ActionDispatch::Executor.new(inner_app, $executor)
end

total = 0
ran = 0
completed = 0

$executor.to_run { total += 1; ran += 1 }
$executor.to_complete { total += 1; completed += 1 }

stack = middleware(proc { [200, {}, "response"] })

requests_count = 5

requests_count.times do
  stack.call({})
end

puts "requests_count: #{requests_count}"
puts "total         : #{total}"
puts "ran           : #{ran}"
puts "completed     : #{completed}"
```
テストコードの通りなら、`to_run`→`to_complete`が5回呼ばれてこんな出力が期待されるはず。
```shell
requests_count: 5
total         : 9
ran           : 5
completed     : 4
```

ところが実際の出力はこう。
```shell
$ bundle exec ruby ./sample.rb
requests_count: 5
total         : 1
ran           : 1
completed     : 0
```
1回しか`to_run`呼ばれてないし、`to_complete`に関しては1度も呼ばれてやがらない模様。
なんでこうなるのかデバッガで見てみる。

- 1周目は、`active?`が`false`になるので`to_run`が実行される。そのまま返ってきて、登録したミドルウェアの処理が実行される。レスポンスは`true`になる値が返されるので、`to_complete`も呼ばれない。
- 2周目からは、どうやら`to_complete`が呼ばれなかった影響で`active?`が`true`のままなので`to_run`が実行されない。

この「`to_complete`が呼ばれない」という現象が割と重く、実際の`Rails`のコードでは`to_complete`でいろいろとスレッドの内部状態をリセットしていたりするもので、このままではこれらのコードが呼ばれることなく次のリクエストの処理に使い回されてしまうというわけ。
```ruby
...
    initializer "active_support.reset_execution_context" do |app|
      app.reloader.before_class_unload { ActiveSupport::ExecutionContext.clear }
      app.executor.to_run              { ActiveSupport::ExecutionContext.clear }
      app.executor.to_complete         { ActiveSupport::ExecutionContext.clear }
    end

    initializer "active_support.reset_all_current_attributes_instances" do |app|
      executor_around_test_case = app.config.active_support.executor_around_test_case

      app.reloader.before_class_unload { ActiveSupport::CurrentAttributes.clear_all }
      app.executor.to_run              { ActiveSupport::CurrentAttributes.reset_all }
      app.executor.to_complete         { ActiveSupport::CurrentAttributes.reset_all }
...
```

試しに概要でも触れられていた`ActiveSupport::CurrentAttributes`というスレッド内で共有できるシングルトンを使ってみると、
```ruby
require 'action_dispatch/middleware/executor'
require 'active_support/code_generator'
require 'active_support/current_attributes'
require 'active_support/executor'
require 'active_support/isolated_execution_state'
require 'debug'

class Current < ActiveSupport::CurrentAttributes
  attribute :account, :user
  attribute :request_id, :user_agent, :ip_address

  # resets { Time.zone = nil }
  resets {}

  def user=(user)
    super
    self.account = user.account
    Time.zone    = user.time_zone
  end
end

$executor = Class.new(ActiveSupport::Executor)

def middleware(inner_app)
  ActionDispatch::Executor.new(inner_app, $executor)
end

total = 0
ran = 0
completed = 0

$executor.to_run { Current.request_id = 1; total += 1; ran += 1 }
$executor.to_complete { ActiveSupport::CurrentAttributes.reset_all; total += 1; completed += 1 }

stack = middleware(proc { Current.request_id += 1; [200, {}, "response"] })

requests_count = 5

requests_count.times do
  # debugger
  stack.call({})
end

puts "requests_count: #{requests_count}"
puts "total         : #{total}"
puts "ran           : #{ran}"
puts "completed     : #{completed}"
puts "Current.request_id: #{Current.request_id}"
```
本来`to_complete`が呼ばれてリセットされてほしいわけだが、こんな感じでリクエストごとにそのまま値が引き回されてしまっている。
```shell
$ bundle exec ruby ./sample.rb
requests_count: 5
total         : 1
ran           : 1
completed     : 0
Current.request_id: 6
```


`ActionDispatch::Executor#call`からミドルウェアが呼ばれる
⬇
ミドルウェアから変なレスポンスが返ってくる
⬇
レスポンスは何かしら返ってきているので、`returned`は`true`となり`state.complete!`が呼ばれない
⬇
スレッドの内部状態がクリアされることなく、後続のリクエストでそのまま使ってしまう
⬇ (⬆ ここまでが`Rails`の脆弱性)
変なレスポンスがそのまま`Puma`に返される
⬇
`Puma`側のバグで更になんか起きる

## 調査用の`Rails`プロジェクト
雑に事前知識を入れ込んどいた所で、前回の`Ruby`の時同様動的にデバッグしていきたいので、それ用の`Rails`プロジェクトも用意しておく。
```shell
# Rubyはインストール済みの前提

# パッチが当たっていない`7.0.2`の`Rails`をインストール
$ gem install rails -v 7.0.2
$ rails _7.0.2_ --version
Rails 7.0.2

# 適当にプロジェクト作成 (検証用のため色々スキップ)
$ rails _7.0.2_ new explore_cve-2022-23633 \
> --skip-git \
> --skip-keeps \
> --skip-active-record \
> --skip-bundle

# 検証用のコントローラも適当に作成 (rootにhoge#indexを設定しておく)
$ rails g controller hoge index --no-helper

# 準備できた
$ rails s
$ curl -i http://localhost:3000/
HTTP/1.1 200 OK
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 0
X-Content-Type-Options: nosniff
...
```

# デバッグしていく
激浅な事前知識も調査用のプロジェクトも準備できた所で、実際に動かしながらデバッグしていく。
デバッグするに当たっては、`v7`系の`Rails`ならデフォルトで組み込まれている[`debug gem`](https://github.com/ruby/debug)を使っていく。
起動方法は簡単で、デバッグを開始したい任意の場所に`debugger`メソッドを埋め込むだけで、そこを通過したタイミングでデバッガが起動してくれるようになる。
あとは好きな所にブレークポイントを入れたりすればオッケー。
```shell
$ cat app/controllers/hoge_controller.rb
class HogeController < ApplicationController
  def index
    debugger  # この辺に入れ込んでおく
  end
end

# 開発サーバーを起動後、ブラウザやらなんやらでアクセスすればサーバーを起動しているコンソール上でデバッガが起動する
$ ./bin/rails s
Started GET "/" for 127.0.0.1 at 2022-mm-dd hh:mm:ss +0900
Processing by HogeController#index as HTML
[1, 5] in path/to/explore_cve-2022-23633/app/controllers/hoge_controller.rb
     1| class HogeController < ApplicationController
     2|   def index
=>   3|     debugger
     4|   end
     5| end
=>#0	HogeController#index at path/to/explore_cve-2022-23633/app/controllers/hoge_controller.rb:3
  #1	ActionController::BasicImplicitRender#send_action(method="index", args=[]) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_controller/metal/basic_implicit_render.rb:6
  # and 68 frames (use `bt' command for all frames)
(rdbg)
```
デバッガが起動後の使い方は今回は割愛するので、気になる方はこれも[公式のHOW TO USE](https://github.com/ruby/debug#how-to-use)を参照。
コマンドセットなどは`gdb`のそれを踏襲した感じなので、`gdb`を使える人なら感覚的にいけるはず。

## リクエストを受けてからどんな呼び出しが行われているのか？
概要文にもある通り、今回の脆弱性は`ActionDispatch::Executor`が肝になるわけだが、そもそもそれがどういう過程で呼び出されるのかがよくわかってない。
また`Rails`の仕組みを学ぶという目的もあるので、まずは`bt (backtrace)`コマンドを使ってコントローラにたどり着くまでの呼び出し経路を調べてみる。(結構長かったので一部省略)
```shell
(rdbg) bt    # backtrace command
=>#0	HogeController#index at path/to/explore_cve-2022-23633/app/controllers/hoge_controller.rb:3
  #1	ActionController::BasicImplicitRender#send_action(method="index", args=[]) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_controller/metal/basic_implicit_render.rb:6
  #2	AbstractController::Base#process_action at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/abstract_controller/base.rb:215
  #3	ActionController::Rendering#process_action at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_controller/metal/rendering.rb:53
        ...
        🔍 継承元の`ActionController`からユーザー定義のコントローラに伝播させているように見える
  #6	AbstractController::Callbacks#process_action at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/abstract_controller/callbacks.rb:233
  #7	ActionController::Rescue#process_action at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_controller/metal/rescue.rb:22
        ...
        🔍 ActionDispatchがコントローラを決定して繋いでいるように見える
  #18	ActionDispatch::Routing::RouteSet::Dispatcher#dispatch(controller=HogeController, action="index", req=#<ActionDispatch::Request GET "http://loc..., res=#<ActionDispatch::Response:0x00007f080159...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_dispatch/routing/route_set.rb:49
  #19	ActionDispatch::Routing::RouteSet::Dispatcher#serve(req=#<ActionDispatch::Request GET "http://loc...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_dispatch/routing/route_set.rb:32
        ...
        🔍 ActionDispatchがクッキーを処理しているように見える
  #32	ActionDispatch::Cookies#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_dispatch/middleware/cookies.rb:696
        ...
        👇 ここが脆弱性の概要で触れられていた、例の`ActionDisptch::Executor` 👇
  #36	ActionDispatch::Executor#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_dispatch/middleware/executor.rb:14
  #37	ActionDispatch::ActionableExceptions#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_dispatch/middleware/actionable_exceptions.rb:17
  #38	ActionDispatch::DebugExceptions#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_dispatch/middleware/debug_exceptions.rb:28
        ...
        🔍 Rackによるロギングが行われているように見える
  #44	Rails::Rack::Logger#call_app(request=#<ActionDispatch::Request GET "http://loc..., env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/railties-7.0.4/lib/rails/rack/logger.rb:40
        ...
        🔍 アクセス元のIPとかをなんかゴニョゴニョしているように見える
  #51	ActionDispatch::RemoteIp#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_dispatch/middleware/remote_ip.rb:93
  #52	ActionDispatch::RequestId#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_dispatch/middleware/request_id.rb:26
        ...
        👇 なんかここにも`ActionDispatch::Executor`がある 👇
  #59	ActionDispatch::Executor#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.4/lib/action_dispatch/middleware/executor.rb:14
        ...
        🔍 Railsに処理が渡されているように見える
  #63	Rails::Engine#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/railties-7.0.4/lib/rails/engine.rb:530
        ...
        🔍 Pumaがリクエストを受けてるように見える
  #67	Puma::Request#handle_request(client=#<Puma::Client:0x2f80 @ready=true>, lines="", requests=1) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/puma-5.6.5/lib/puma/request.rb:76
  #68	Puma::Server#process_client(client=#<Puma::Client:0x2f80 @ready=true>, buffer="") at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/puma-5.6.5/lib/puma/server.rb:443
  #69	block {|spawned=2|} in spawn_thread at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/puma-5.6.5/lib/puma/thread_pool.rb:147
```
こうやって見てみると、実際に`Puma`から繋がれた後いろいろあって`ActionDispatch`によってルーティングやクッキーが処理されていたりする様子がよくわかって感動。
ちょっと見やすくするために、スタックを逆さまにして上から順番にアウトラインにするとこんな感じ。


1. `Puma`がバインドされているポートにリクエストが届き、`Puma::Server#process_client`が呼ばれる
   a. `Puma::Request#handle_request`で、リクエストの処理に移る
2. `Puma`から`Rails`に処理が移る(Rackインターフェースに準拠した`Rails::Engine#call`が呼ばれる)
3. `Rails::Engine`内でリクエストを`ActionDispatch::Request`にマッピング、Rackミドルウェアに繋ぐ (ここからコントローラまでミドルウェアの連鎖)
   a. `ActionDispatch::HostAuthorization#call`によるDNS-Rebinding攻撃の検査
   b. `ActionDispatch::Static#call`による静的ファイルの検索
   c. `ActionDispatch::ServerTiming#call`による`Server-Timing`ヘッダーの処理
   d. `ActiveSupport::Cache::Strategy::LocalCache::Middleware#call`によるキャッシュの操作
   e. `ActionDispatch::Executor#call` 👈
   f. ロギング
   g. `ActionDispatch::RequestId#call`によるRequest IDの発行
   h. `ActionDispatch::RemoteIp#call`によるアクセス元のIPの解決(プロキシ環境の場合など)
   i. `ActionDispatch::Executor#call` 👈
   j. `ActionDispatch::ContentSecurityPolicy::Middleware#call`による`Content-Security-Policy`の検証
   k. などなど...
5. `ActionDispatch::Routing::RouteSet#call`→`ActionDispatch::Jorney::Router#serve`→`ActionDispatch::Routing::RouteSet::Dispatcher#serve`でコントローラが解決され処理が引き渡される
6. いろいろあって`ActionController::Rendering#process_action`とか経由し、ユーザー定義のコントローラまでたどり着く
7. この後コールスタックを戻っていく過程で`ActionView`とかでレスポンスを構築。
最終的に`Rails::Engine#call`の呼び出し元に`[staus_code as int, headers as HashMap, responses as Array]`という感じの配列が返され、`Puma`がソケットにレスポンスをバイト列として書き込んで終了

## `ActionDispatch::Executor#call`は内部で何をしている？
呼び出しのバックトレースを確認して`ActionDispatch::Executor`の呼び出し場所がわかった所で、実際に何をしているのかもう少し見ていく。
`ActionDispatch::Executor#call`が呼ばれる場所にブレークポイントを置いて実行を止めてみる。

```shell
(rdbg) b ActionDispatch::Executor#call

... # 一度処理を最後まで走らせて、再度http://localhost:3000/にアクセス

[7, 16] in path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.2/lib/action_dispatch/middleware/executor.rb
     7|     def initialize(app, executor)
     8|       @app, @executor = app, executor
     9|     end
    10|
    11|     def call(env)
=>  12|       state = @executor.run!
    13|       begin
    14|         response = @app.call(env)
    15|         returned = response << ::Rack::BodyProxy.new(response.pop) { state.complete! }
    16|       rescue => error
=>#0	ActionDispatch::Executor#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.2/lib/action_dispatch/middleware/executor.rb:12
  #1	ActionDispatch::Static#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at path/to/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.2/lib/action_dispatch/middleware/static.rb:23
  # and 9 frames (use `bt' command for all frames)

Stop by #0  BP - Method  ActionDispatch::Executor#call at /home/kate/.asdf/installs/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.2/lib/action_dispatch/middleware/executor.rb:11
(rdbg)
```
止まった。現在の変数などを表示させてみる。

```shell
(rdbg) i    # info command
%self = #<ActionDispatch::Executor:0x00007fd66e2f2c58 @app=#<ActionDispatch::ServerTiming:0x00007fd66e2f2cf8 @app=#<ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x00007fd66ed8e338 @name="ActiveSupp...>
env = {"rack.version"=>[1, 6], "rack.errors"=>#<IO:<STDERR>>, "rack.multithread"=>true, "rack.multiprocess"=>false, "rack.run_once"=>false, "rack.url_scheme"=>"http", "SCRIPT_NAME"=>"", "QUERY_STRING"=>"", "S...
state = nil
response = nil
returned = nil
error = nil
@app = #<ActionDispatch::ServerTiming:0x00007fd66e2f2cf8 @app=#<ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x00007fd66ed8e338 @name="ActiveSupport::Cache::Strategy::LocalCache", @local_cache_key=...>
@executor = #<Class:0x00007fd66ede22f8>
```
インスタンス変数の`@app`には`ActionDispatch::ServerTiming`と書かれているので、次に連鎖させるミドルウェアが入っていると思われる。
肝心の`@executor`はこのままでは`Class`としか表示されなかったので、ステップ実行で入り込んで見る。

```shell
(rdbg) s    # step command
[63, 72] in ~/.asdf/installs/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/activesupport-7.0.2/lib/active_support/execution_wrapper.rb
    63|     # Returns an instance, whose +complete!+ method *must* be invoked
    64|     # after the work has been performed.
    65|     #
    66|     # Where possible, prefer +wrap+.
    67|     def self.run!
=>  68|       if active?
    69|         Null
    70|       else
    71|         new.tap do |instance|
    72|           success = nil
=>#0	#<Class:ActiveSupport::ExecutionWrapper>#run! at ~/.asdf/installs/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/activesupport-7.0.2/lib/active_support/execution_wrapper.rb:68
  #1	ActionDispatch::Executor#call(env={"rack.version"=>[1, 6], "rack.errors"=>...) at ~/.asdf/installs/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/actionpack-7.0.2/lib/action_dispatch/middleware/executor.rb:12
  # and 10 frames (use `bt' command for all frames)
```
`ActiveSupport::ExecutionWrapper`が出てきた。
ここの`active?`メソッドで現在のスレッド中で実行中であるかを確認し、実行中であれば何もせず`Null`を返し、そうでなければ自分自身をインスタンス化して`run!`メソッドを呼び出す。
もちろん初回実行時は`active?`は`false`を返す。

## パッチ適用前後の違い
今回のパッチで大きく変更されているのが特にこの`ActiveSupport::ExecutionWrapper#run!`の部分なのだが、何が変更されているかというと、

`ActiveSupport::ExecutionWrapper`内で`ActiveSupport::IsolatedExecutionState.unique_id`を管理していた
  (`ExecutionWrapper.active`というHashMap内で、`IsolatedExecutionState.unique_id`をキーにbooleanを値にして管理している)p
⬇ (依存の向き先が逆になった)
`ActiveSupport::IsolatedExecutionState`内で`ActiveSupport::ExecutionWrapper.active_key`を管理するようにした
  (`Isolatedexecutionstate.current`から取れる、`Thread.current.active_support_execution_state`という`HashMap`に`active_execution_wrapper_{ExecutionState.object_id}`となるキー、`ExecutionWrapper`への参照を値として管理している)

### 挙動の変化
`ExecutionWrapper`が`active?`であれば`Null`を返す、そうでなければ`run_callbacks`を呼び出す。
⬇
`ExecutionWrapper`の`run!`に渡された`reset`が`true`であれば`IsolatedExecutionState`から自分を削除し`run_callbacks`を呼び出す、そうでなく`active?`であれば`Null`を返す。

### `active?`であるとは？
`ExecutionWrapper`に`IsolatedExecutionState`が登録されている状態。
```ruby
def self.active? # :nodoc:
  @active[IsolatedExecutionState.unique_id]
end
```
⬇
`ExecutionWrapper`が`IsolatedExecutionState`に登録されている状態。
```ruby
def self.active? # :nodoc:
  IsolatedExecutionState.key?(active_key)
end
```



---




さらにこの脆弱性のパッチは`Puma`にも関係しており、

`Puma`がバグのある`Rack`ミドルウェアのレスポンスに対して適切な処理がかけれていない点(読み込みすぎる)、`Rails`側で`Thread`の状態を適切にクリアできていない点()の合わせ技で連続するリクエストにデータが漏洩する可能性がある。

Aという処理があるスレッドで処理され`IsolatedExecutionState`内を消せずに処理を終了してしまう。
Bという別の処理が同じ実行されたタイミングで、

変な挙動をするミドルウェアを用意して、`ActiveSupport::CurrentAttributes`を使って何かしらを使えば再現できそうな雰囲気が出ている。

## メモ



### そもそも`ExecutionWrapper`/`IsolatedExecutionState`はなんなのか？



### `IsolatedExecutionState.unique_id`はなんなのか？
現在の実行単位(`Thread`もしくは`Fiber`)の`active_support_execution_state`に含まれる`__id__`シンボルの値。
初回アクセス時に空の`Object`がインスタンス化されたものが代入され、そのインスタンスが一意なIDとしての役割を持つ。
```ruby
module ActiveSupport
  module IsolatedExecutionState # :nodoc:
      ...
      def unique_id
        self[:__id__] ||= Object.new
      end
```

### `Thread.current.active_support_execution_state`は具体的に何を保存したいのか
「`ExecutionWrapper`を一意に識別するID」を保存したい。
おそらく、リロード処理のような処理が1つの実行コンテキスト(ThreadかFiber)で何度も実行されないように排他処理がしたい？
それにしても`ExecutionWrapper`って名前からなんなのかわかりづらくないか...？

### 今回のケースでは、なんの処理が`ExecutionWrapper`によって実行されるのか
インクルードしている`ActiveSupport::Callbacks`モジュールの`run_callbacks`が呼ばれる。
内部では、`__callbacks`というHashMapの`:run`をキーとする`ActiveSupport::Callbacks::CallbackChain`が呼ばれる。
まず呼ばれるのはリロード処理。事前に`ActiveSupport::Reloader#check!`でリロードするべきかチェックした後、実際にコールバックを実行する親クラスの`ExecutionWrapper#run!`に入ってくる。

### `ExecutionWrapper`内で`IsolatedExecutionState`を管理することの何が問題だったのか？ (なぜ`IsolatedExecutionState`に`ExecutionWrapper`を管理させる方針に変える必要があったのか)
ここまでの実行ステップを整理。(パッチ適用前の動き)
- リクエストが到達する
⬇
- 色々あってリクエストで送られたパスとメソッドに該当するコントローラが解決される
⬇
- コントローラに繋ぐ前に、リロードすべきかチェックする(ファイルが変更されているかなどを確認)
⬇
- リロードすべきと判断した場合、リロード処理を行う一連のコールバックに入る
⬇
- コールバック実行開始前に`ExecutionWrapper`に`IsolatedExecutionState`を登録する(ここで登録されるのはインスタンスではなくクラス自体のためどのリクエストでも同じ静的な値)
⬇
- リロード処理が行われる
⬇
- 事後処理として`ExecutionWrapper`から登録した`IsolatedExecutionState`を削除

これがこうなる。

- リクエストが到達する
⬇
- 色々あってリクエストで送られたパスとメソッドに該当するコントローラが解決される
⬇
- コントローラに繋ぐ前に、リロードすべきかチェックする(ファイルが変更されているかなどを確認)
⬇
- リロードすべきと判断した場合、リロード処理を行う一連のコールバックに入る
⬇
- コールバック実行開始前に`IsolatedExecutionWrapper`に`ExecutionWrapper`を登録する(ここで登録されるのは`ExecutionWrapper`クラスの`object_id`を使った文字列がキーでインスタンスが値)
⬇
- リロード処理が行われる
⬇
- 事後処理として`ExecutionWrapper`から登録した`IsolatedExecutionState`を削除

`ExecutionWrapper`内で`IsolatedExecutionState`を管理する場所としてクラス変数のHashMapを使用していたのだが、`ExecutionWrapper`自体は継承されて使われる可能性があるため、全然関係ない子クラスたちの間でも`IsolatedExecutionState`を管理している状態が共有されてしまう？
例えば...
`ExecutionWrapper`を継承した`A`と`B`というクラスがあるとして、`A`を実行したタイミングで親クラスのクラス変数に`IsolatedExecutionState`クラスの`object_id`がセットされる。
これはクラス変数で管理されているため、同じく`ExecutionWrapper`を継承している`B`にも影響し、この間に`B`も実行されると`active?`が`true`になる。
`B`で実行される想定の処理が実行されず、予期せぬ挙動を起こす。

これを「実行中の`ExecutionWrapper`を`IsolatedExecutionState`のクラス変数で単一管理」するようにすることで、`IsolatedExecutionState`は継承されたりするものでもないので上記のような挙動をすることがなくなる。

#### つまり
「実行コンテキスト内で`ExecutionWrapper` **に** `IsolatedExecutionState`を入れて実行中かどうかを判定している」か、「`ExecutionWrapper` **を** `IsolatedExecutionState`に入れて実行中かどうか判定している」かの違い。
前者は「各実行対象のクラスに実行コンテキストを紐付けておいて、ここで実行中ですよという印でこのクラスがactiveか判定している」のと、後者は「各実行対象のクラスを実行コンテキストに紐づけて、この実行コンテキストではこのクラスが実行中ですよという印でactiveかどうか判定している」。

パッチでは、`ActionDispath::Executor#call`からは毎回明示的に`reset = true`として呼び出すことで、前回の実行状態を確実にクリアしてからリクエストの処理に進むようになっている。

`ActionDispatch::Executor#call`からミドルウェアが呼ばれる
⬇
ミドルウェアから変なレスポンスが返ってくる
⬇
レスポンスは何かしら返ってきているので、`returned`は`true`となり`state.complete!`が呼ばれない
⬇
スレッドの内部状態がクリアされることなく、後続のリクエストでそのまま使ってしまう
⬇ (⬆ ここまでが`Rails`の脆弱性)
変なレスポンスがそのまま`Puma`に返される
⬇
`Puma`側のバグで更になんか起きる



## 「どこで」「なにを」**リセット**しているのか？
`reset`という引数が追加されていることがわかったので、この値によって何が起きているのかもう少し深く見ていく。

### ActiveSupport::Reloader#run!
そもそもこのパッチが当てられているソースコードの場所だが、[`rails/activesupport/lib/active_support/reloader.rb:61`](https://github.com/rails/rails/blob/f9a2ad03943d5c2ba54e1d45f155442b519c75da/activesupport/lib/active_support/reloader.rb#L61)にある。
```ruby
module ActiveSupport
  ...

  class Reloader < ExecutionWrapper
    ...

    def self.run!(reset: false) # :nodoc:
      if check!
        super
      else
        Null
      end
    end
    ...
```

`ActiveSupport`モジュール内の`Reloader`クラスのクラスメソッドとして定義されている`run!`メソッド。
ここで`reset`引数がそのまま`super`に渡されることになる。
`Reloader`クラスは`ExecutionWrapper`を継承しているため、`ExecutionWrapper`を見てみる。

ちなみに、`ActiveSupport`は`Rails`内で使われるユーティリティ系のクラスや標準ライブラリの拡張を提供するコード郡だが、今回は細かい説明は割愛する。
気になる方は[公式のドキュメント](https://github.com/rails/rails/blob/main/activesupport/README.rdoc)を参照。

### ActiveSupport::ExecutionWrapper
`ExecutionWrapper`の本体は[`rails/activesupport/lib/active_support/execution_wrapper.rb:8`](https://github.com/rails/rails/blob/f9a2ad03943d5c2ba54e1d45f155442b519c75da/activesupport/lib/active_support/execution_wrapper.rb:8)で定義されている。
`run!`メソッドを見てみるとこんな感じ。
```ruby
module ActiveSupport
  class ExecutionWrapper
    ...
    # Run this execution.
    #
    # Returns an instance, whose +complete!+ method *must* be invoked
    # after the work has been performed.
    #
    # Where possible, prefer +wrap+.
    def self.run!(reset: false)
      if reset
        lost_instance = IsolatedExecutionState.delete(active_key)
        lost_instance&.complete!
      else
        return Null if active?
      end

      new.tap do |instance|
        success = nil
        begin
          instance.run!
          success = true
        ensure
          instance.complete! unless success
        end
      end
    end
    ...
```

`reset`が真の時、`IsolatedExecutionState`を`delete`している。
その後自分自身を[`new`](https://docs.ruby-lang.org/ja/latest/class/Class.html#I_NEW)でインスタンス化、[`tap`](https://docs.ruby-lang.org/ja/latest/class/Object.html#I_TAP)で渡したブロックでインスタンスの`run!`メソッドを呼び出している。

`ExecutionnWrapper`の`run!`インスタンスメソッドはこれ。
```ruby
def run! # :nodoc:
  IsolatedExecutionState[self.class.active_key] = self
  run
end
```

`IsollatedExecutionState`の`active_key`なるものに自分自身を設定した後、`run`メソッドに繋いでいる。いずれにしても`IsolatedExecutionState`クラスを見ていくことになる。

### `ActiveSupport::IsolatedExecutionState`
`IsolatedExecutionState`の本体は[`rails/activesupport/lib/active_support/isolated_execution_state.rb:#L6`](https://github.com/rails/rails/blob/f9a2ad03943d5c2ba54e1d45f155442b519c75da/activesupport/lib/active_support/isolated_execution_state.rb#L6)にある。
```ruby
module ActiveSupport
  module IsolatedExecutionState # :nodoc:
    ...
    class << self
      ...

      def []=(key, value)
        state[key] = value
      end

      ...

      def delete(key)
        state.delete(key)
      end

      ...

      def context
        scope.current
      end

      private
        def state
          context.active_support_execution_state ||= {}
        end
    end

    ...
  end
end
```

見た所、
